Add integration tests (Sign)
  -strict fails when using untrusted key
  -strict fails when using key with no CodeSigning



When it comes to jarsigner mojo, I'd love to learn how to take configuration values
  as multi-faceted inputs like the following:

  <provider>
     <class>xpertss.crypto.kms.provider.KmsProvider</class>
     <arg>SomeStringArg</arg>
  </provider>
  <digest>
     <algorithm>SHA-256</algorithm>
     <provider>SUN</provider>
  </digest>




So the current maven-jarsigner-plugin operates by invoking the command line jarsigner.
  I want to create a new one that operates by calling the methods in the main.class
  associated with the jarsigner in the SUN code base. I will probably extract the
  methods and objectize things a bit so I don't have to deal with all of the MAIN
  argument parsing (nor the hundreds of variants).
  
  In my case the AWS KMS JCE Provider will already be part of the process and the
  dependency set. Maybe Bouncy Castle too??

  In the above case if I merge the Main class into this module then I do not need
  tools.jar to be in the classpath. Otherwise, I do.

  An alternative might be to simply construct the appropriate classpath and pass
  it to the existing jarsigner along with the -J-cp argument.


  So there is a special PluginClassLoader which extends the Project class loader.
  All of the dependencies defined by the Plugin are by default within this class
  loader and can be extended as an example:

       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-antrun-plugin</artifactId>
         <version>1.3</version>
         <dependencies>
           <dependency>
             <groupId>org.apache.ant</groupId>
             <artifactId>ant-nodeps</artifactId>
             <version>1.7.1</version>
           </dependency>
         </dependencies>
         ...
       </plugin>

  Plugins can inspect their effective runtime class path via the expressions
  ${plugin.artifacts} or ${plugin.artifactMap} to have a list or map, respectively,
  of resolved artifacts injected from the PluginDescriptor.

  https://maven.apache.org/guides/mini/guide-maven-classloading.html#Plugin_Classloaders



  Create an integration test to explicitly test the use case where the
  jar signer plugin has the following code added to it's definition



      <plugin>
        <groupId>org.xpertss.maven.plugins</groupId>
        <artifactId>jarsigner-maven-plugin</artifactId>
        <version>1.0.0-SNAPSHOT</version>
        <dependencies>
          <dependency>
            <groupId>org.xpertss</groupId>
            <artifactId>aws-kms</artifactId>
            <version>1.0.0-SNAPSHOT</version>
            <scope>runtime</scope>
          </dependency>
        </dependencies>
        <configuration>
          <alias>AWS-KMS-KEY-ALIAS</alias>
          <storetype>KMS</storetype>
          <keystore>NONE</keystore>
          <providerClass>xpertss.crypto.kms.provider.KmsProvider</providerClass>
          <certchain>kms-rsa4096-certchain.pem</certchain>
          <sigfile>TESTING</sigfile>
          <processMainArtifact>false</processMainArtifact>
          <archiveDirectory>target/classes/jars</archiveDirectory>
        </configuration>
        <executions>
          <execution>
            <id>sign-jars</id>
            <goals>
              <goal>sign</goal>
            </goals>
          </execution>
          <execution>
            <id>verify-jars</id>
            <goals>
              <goal>verify</goal>
            </goals>
          </execution>
        </executions>
      </plugin>



















Maybe we should create an IdentityProvider/Builder that takes the various keystore parameters (and alias) and wraps them into a
mechanism to load keys/certs and to validate those certs including any sort of TrustStore. An alternative name might be Signer.
(keystore is /keystore in $user.home if not specified. Use NONE to indicate the actual file.


Identity class has getCertificate(), getCertificateChain(), getPrivateKey(), and getName() methods.


I’d like to have a trust store parameter that allows me to specify what trusted key store to use. If unset we default to the
standard java trusted keystore. Otherwise, we use the one specified as a file Path.


What sort of certificate validation do we really want on signing? There is validating that the certificate allows codesigning
(key usage, extended key usage).. And then there is the CertPath Trust model (PKIX). Do we do both or just the former? The
later seems more relevant to verify than sign.

By default jarsigner treats certificate validation errors as warnings, unless -strict is used at which point they are errors.


Signing Cert appears to be part of the SignatuereBlock???


Apparently, verify really only verifies that the contents of the JAR have no been changed from when it was signed. It does
NOT (unless -strict is specified) fail because it there is an issue with the signing cert (key usage or trust). It also
does not be default error on unsigned entries in the


I don’t have any interest in supporting the older Netscape X509 extensions like the default jarsigner does.


On verify (if strict) it will error if jar is not signed by the specified key. Equivalent to certificate pinning.



I can create SignatureFile and SignatureBlock to represent the two files added to the JAR as part of signing.. Likewise,
it should be capable of reading and verifying.

Also should have some sort of TSA Impl. Maybe both to track the params but also to perform the work. The jarsigner uses a
subclass called Signer (or altsigner) which performs the work. It is currently deprecated but I am might try a similar
approach in my impl.


Options Specific to Either Sign or Verify
•	-storepass, -keypass -keystore -storetype, -certchain, and Alias


Options specific to SignJar
•	-sigfile, -sigalg, -digestalg, -signedjar

Options specific to Verify
•	-certs

Options built around Providers (possibly both verify and sign)..
  ProviderClass may just add to Security system, while providerArg is passed to each algorithm load
•	-providerClass, -providerName, -providerArg

TSA Options (predominately signing)
•	-tsa, -tsapolicyid, -tsacert

Runtime Options (protected means nothing in a maven context)
•	-strict, -verbose, -protected

New Options I’d like to add (java default cacerts file as an example)
•	-truststore



Verification
https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html#CCHDAJHB








    <executions>
      <execution>
        <id>sign-jars</id>
        <goals>
          <goal>sign</goal>
        </goals>
        <configuration>
            <!-- Config that applies only to sign -->
            <digest>
              <algorithm>SHA-256</algorithm>
              <provider>SUN</provider>
            </digest>
            <keypass>key-pass</keypass>
        </configuration>
      </execution>
      <execution>
        <id>verify-jars</id>
        <goals>
          <goal>verify</goal>
        </goals>
        <configuration>
            <!-- Config that applies only to verify -->
          <certs>true</certs>
        </configuration>
      </execution>
    </executions>


  <execution>
    <id>execution2</id>
    <phase>install</phase>
    <configuration>
      <url>http://www.bar.com/query</url>
      <timeout>15</timeout>
      <options>
        <option>four</option>
        <option>five</option>
        <option>six</option>
      </options>
    </configuration>
    <goals>
      <goal>query</goal>
    </goals>
  </execution>


